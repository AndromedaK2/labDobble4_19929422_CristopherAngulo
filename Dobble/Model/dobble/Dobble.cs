using Model.card;
using System;
using System.Collections.Generic;
using System.Linq;
 
namespace Model.dobble
{

	public class Dobble : IDobble
	{

		#region attributes
		/// <summary>
		/// @description Id is generated by a random function </summary>
		private readonly int Id;
		/// <summary>
		/// @description represent card list of dobblegame
		/// </summary>
		public List<Card> DobbleCards { get; set; } = new();

        /// <summary>
        /// @description represent order of dobble (projective plane)
        /// </summary>
        private int order;

        //endregion

        //region getter and setters


        /// <summary>
        /// @implNote  get missing cards </summary>
        /// <returns> card list </returns>
        public List<Card> MissingCards { get; } = new List<Card>();

        /// <summary>
        /// @implNote get elements </summary>
        /// <returns> elements </returns>
        public List<object> AllElements { get; }

        /// <summary>
        /// @implNote get max total cards </summary>
        /// <returns> cards </returns>
        public int MaximumTotalCards { get; }

        /// <summary>
        /// @implNote get elements per card </summary>
        /// <returns> elementsPerCard </returns>

        public int ElementsPerCard { get; }

		#endregion

		#region constructor

		/// <summary>
		/// Main Constructor
		/// @description create first card, create n cards, create n^2 cards. Shuffle Cards
		/// validate if total cards is equal to max number of cards, if not true we refill dobble cards and missing cards </summary>
		/// <param name="elements">  symbols or elements of cards </param>
		/// <param name="elementsPerCard"> quantity elements per card </param>
		/// <param name="maximumTotalCards"> maximum total cards of deck </param>
		public Dobble(List<object> elements, int elementsPerCard, int maximumTotalCards)
		{ 
			this.Id = Helper.GenerateRandomNumber(1, 10000000);
			this.AllElements = elements;
			this.ElementsPerCard = elementsPerCard;
			this.order = GetOrder(elementsPerCard);
			this.MaximumTotalCards = maximumTotalCards;
			AddCard(CreateFirstCard(elements, order));
			AddCards(CreateNCards(elements, order));
			AddCards(CreateNSquareCards(elements, order));
			Shuffle();
			if (!(GetMaxNumberOfCards(order) == maximumTotalCards))
			{
				List<Card> DobbleCards = new();
				int i = 0;

				for (; i < maximumTotalCards; i++)
				{
					DobbleCards.Add(this.DobbleCards[i]);
				}

				for (int j = i; j < this.DobbleCards.Count; j++)
				{
					MissingCards.Add(this.DobbleCards[j]);
				}

				this.DobbleCards = DobbleCards;

			}
		}

		#endregion

		#region public methods

		/// <summary>
		/// @implNote  accord two assumptions we return true if  all cards have different elements inside and
		/// between all cards have only one element in common </summary>
		/// <returns> true if is dobble or false if is not </returns>
		public  bool IsDobble()
		{ 
			bool AllCardsHaveDifferentElements = this.AllCardsHaveDifferentElements();
			bool betweenAllCardsHaveDifferentElements = this.BetweenAllCardsHaveOneElementInCommon();
			return (AllCardsHaveDifferentElements && betweenAllCardsHaveDifferentElements);
		}

		/// <summary>
		/// @implNote this method return missing cards in a string format similar to dobble cards </summary>
		/// <returns> representation of missing cards in string </returns>
		public string GetMissingCards()  
		{
			string missingCardsString = "\nCartas Faltantes: \n";
			for (int i = 0; i < MissingCards.Count; i++)
			{
				Card card = MissingCards[i];
				string cardString = card.ToString();
				missingCardsString = missingCardsString + cardString;
			}
			return "" + missingCardsString;
		}

		/// <summary>
		/// @implNote get a card of card list with a specific position </summary>
		/// <param name="cards"> represent list of cards where we search </param>
		/// <param name="position"> represent position number (index to search) </param>
		/// <returns> card </returns>
		public Card GetNthCard(List<Card> cards, int position)
		{
			return cards[position];
		}

		/// <summary>
		/// @implNote get a card of card list with a specific position </summary>
		/// <param name="position"> represent position number (index to search) </param>
		/// <returns> card </returns>
		public  Card GetNthCard(int position)
		{
			return this.DobbleCards[position];
		}

		/// <summary>
		/// @implNote </summary>
		/// <param name="card"> </param>
		/// <returns> required elements to create dobble </returns>
		public  int GetRequiredElements(Card card)
		{
			int elementsPerCard = card.Elements.Count();
			int order = GetOrder(elementsPerCard);
			return (order * order) + order + 1;
		} 

		/// <summary>
		/// @implNote  get total cards to create dobble cards </summary>
		/// <param name="card"> represent a card </param>
		/// <returns> total cards to create dobble </returns>
		public  int GetTotalCards(Card card) 
		{
			int elementsPerCard = card.Elements.Count();
			int order = GetOrder(elementsPerCard);
			return (order * order) + order + 1;
		}

		/// <summary>
		/// @implNote  get maximum number of cards that we can create accord the order </summary>
		/// <param name="order"> represent order (projective plane) </param>
		/// <returns> maximum number of cards </returns>
		public virtual int GetMaxNumberOfCards(int order)
		{
			return (order * order) + order + 1;
		}

		/// <summary>
		/// @implNote add cards to dobble cards </summary>
		/// <param name="cards"> represent card list to add </param>
		public void AddCards(List<Card> cards)
		{
			for (int i = 0; i < cards.Count; i++)
			{
				DobbleCards.Add(GetNthCard(cards, i));
			}
		}

		/// <summary>
		/// @implNote  add a new card in dobble cards </summary>
		/// <param name="card"> represent a card of dobble cards </param>
		public void AddCard(Card card) 
		{
			DobbleCards.Add(card);
		}

		/// <summary>
		/// @implNote  remove a card in dobble cards </summary>
		/// <param name="card"> represent a card of dobble cards </param>
		public  void RemoveCard(Card card)
		{ 
			this.DobbleCards.Remove(card);
		}

		/// <summary>
		/// @implNote  this method is overriding to return a dobble string </summary>
		/// <returns> dobble in a string format </returns>
		public override string ToString()
		{
			string dobbleCardsString = "Mazo de cartas: \n";
			for (int i = 0; i < DobbleCards.Count; i++)
			{
				Card card = DobbleCards[i];
				string cardString = card.ToString();
				dobbleCardsString = dobbleCardsString + cardString;
			}
			return dobbleCardsString;
		}


		/// <summary>
		/// @implNote verify if 2 objects are equals accord properties and others validations </summary>
		/// <param name="o"> any object </param>
		/// <returns> true if objects are equals or false if objects are not equals </returns>
		public override bool Equals(object obj)
		{
			return obj is Dobble dobble &&
				   Id == dobble.Id &&
				   EqualityComparer<List<Card>>.Default.Equals(DobbleCards, dobble.DobbleCards) &&
				   order == dobble.order &&
				   EqualityComparer<List<Card>>.Default.Equals(MissingCards, dobble.MissingCards) &&
				   EqualityComparer<List<object>>.Default.Equals(AllElements, dobble.AllElements) &&
				   MaximumTotalCards == dobble.MaximumTotalCards &&
				   ElementsPerCard == dobble.ElementsPerCard;
		}

        #endregion

        /// <summary>
        /// @implNote Create first card </summary>
        /// <param name="elements"> represent object list </param>
        /// <param name="order"> represent order (projective plane) </param>
        /// <returns> The first card of dobble cards </returns>
        private Card CreateFirstCard(List<object> elements, int? order)
		{
			Card card = new();
			for (int i = 0; i < order.Value + 1; i++)
			{
				object element = elements[i];
                card.AddElement(element);
			}
			return card;
		}

		/// <summary>
		/// @implNote  Create N Cards </summary>
		/// <param name="elements"> represent object list </param>
		/// <param name="order"> represent order (projective plane) </param>
		/// <returns> card list accord to N </returns>

		private List<Card> CreateNCards(List<object> elements, int order)
		{
			List<Card> cards = new List<Card>();
			for (int j = 1; j <= order; j++)
			{
				object firstElement = elements[0];
				Card card = new Card();
				card.AddElement(firstElement);

				for (int k = 1; k <= order; k++)
				{
					object element = elements[CalculateIndexToGetNCards(order, j, k)];
					card.AddElement(element);
				}
				cards.Add(card);
			}
			return cards;
		}

		/// <summary>
		/// @implNote  Create N square cards </summary>
		/// <param name="elements"> represent object list </param>
		/// <param name="order"> represent order (projective plane) </param>
		/// <returns> card list accord to N square </returns>
		private List<Card> CreateNSquareCards(List<object> elements, int order)
		{
			List<Card> cards = new List<Card>();
			for (int i = 1; i <= order; i++)
			{
				for (int j = 1; j <= order; j++)
				{
					Card card = new Card();
					card.AddElement(elements[i]);
					for (int k = 1; k <= order; k++)
					{
						object element = elements[CalculateIndexToGetNSquareCards(i, order, j, k)];
						card.AddElement(element);
					}
					cards.Add(card);
				}
			}
			return cards;
		}

		/// <summary>
		/// @implNote  calculate index to get an element in the creation of N cards </summary>
		/// <param name="order"> represent order (projective plane) </param>
		/// <param name="j"> first helper </param>
		/// <param name="k"> second helper </param>
		/// <returns> index to get a element in the creation of N cards. </returns>
		private int CalculateIndexToGetNCards(int order, int j, int k) 
		{
			return (order * j + (k + 1)) - 1;
		}

		/// <summary>
		/// @implNote  calculate index to get an element in the creation of n square cards </summary>
		/// <param name="i"> first helper </param>
		/// <param name="order"> represent order (projective plane) </param>
		/// <param name="j"> second helper </param>
		/// <param name="k"> third helper </param>
		/// <returns> index to get a element in the creation of N square cards. </returns>
		private int CalculateIndexToGetNSquareCards(int i, int order, int j, int k)
		{
			return (order + 2 + order * (k - 1) + (((i - 1) * (k - 1) + j - 1) % order)) - 1;
		}

		/// <summary>
		/// @implNote get order with  element per card input </summary>
		/// <param name="elementPerCard"> represent a number element per card </param>
		/// <returns> order </returns>
		private int GetOrder(int elementPerCard)
		{
			return elementPerCard - 1;
		}

        /// <summary>
        /// @implNote Shuffle current dobble cards
        /// </summary>
        private void Shuffle()
        {
			DobbleCards.Sort((x, y) => x.Id.CompareTo(y.Id));
        }

        /// <summary>
        /// @implNote  validate if all cards have different elements </summary>
        /// <returns> true if all cards have different elements or false if they have not </returns>
        private bool AllCardsHaveDifferentElements()
		{
			return this.DobbleCards.All(card => card.Elements.Distinct().Count() == this.ElementsPerCard);
		}

		/// <summary>
		/// @implNote  validate if between all cards have different elements </summary>
		/// <returns> true if between all cards have different elements or false if they have not </returns>
		private bool BetweenAllCardsHaveOneElementInCommon()
		{
			int auxiliary = 0;
			for (int i = 0; i < DobbleCards.Count(); i++)
			{
				auxiliary++;

				for (int j = auxiliary; j < this.DobbleCards.Count(); j++)
				{
					Card firstCard = this.DobbleCards[i];
					Card nextCard = this.DobbleCards[j];
					if (!(firstCard.Elements.Where(nextCard.Elements.Contains).ToList().Count() == 1))
					{
						return false;
					}
				}
			}
			return true;
		}

        public override int GetHashCode()
        {
			return 0;
        }
    }

}